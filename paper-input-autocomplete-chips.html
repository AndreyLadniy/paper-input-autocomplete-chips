<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-input/paper-input-container.html">
<link rel="import" href="paper-chip.html">
<link rel="import" href="paper-input-autocomplete.html">

<!--
An element providing a solution to no problem in particular.

Example:

    <paper-input-autocomplete-chips></paper-input-autocomplete-chips>

@group Seed Elements
@element paper-input-autocomplete-chips
@demo demo/index.html
@hero hero.svg
-->
<dom-module id="paper-input-autocomplete-chips">
  <template>
    <style>

      :host {
        --autocomplete-chip-margin: 4px 4px 4px 0px;
        --autocomplete-line-height: 40px;

        display: block;

        --paper-chip: {
          display: inline-block;
        }
      }
      
      .prefix-container
      ,.suffix-container {
        line-height: var(--autocomplete-line-height, 40px);
      }

     .prefix-container {
        align-self: flex-start;
        
        @apply(--prefix-container);
      }

      .suffix-container {
        align-self: flex-end;
        
        @apply(--suffix-container);
      }
     
      .complete-input-container {
        display: block;
        overflow-x: hidden;
        -webkit-flex: 1;
        flex: 1;
        direction: ltr;
      }

      paper-input-container::shadow .input-content.paper-input-container {
        align-items: center;
      }

      paper-input-container::shadow .input-content.paper-input-container paper-chip {
        margin: var(--autocomplete-chip-margin, 4px 0px);
      }

      paper-input-container::shadow .input-content.paper-input-container.label-is-floating label {
        top: 0; 
        bottom: auto; 
        line-height: 24px;
      }

      paper-input-container::shadow .input-content.paper-input-container label {
        top: auto; 
        bottom: 0; 
        height: 38px;        
        line-height: var(--autocomplete-line-height, 40px);
      }
                  
      paper-input-container::shadow div.complete-input-container.chip-item-added label {
        line-height: var(--autocomplete-line-height, 40px);
      }

      input#input {
        display: inline-block;
        resize: none;
      }

      paper-input-container::shadow div.complete-input-container input#input {
        height: 38px;        
        line-height: var(--autocomplete-line-height, 40px);
      }
      
      paper-input-container::shadow div.complete-input-container.chip-item-added input#input {
        width: 60%;
      }

      paper-input-container::shadow div.complete-input-container:not(.chip-item-added) input#input {
        width: 100%;
      }
     
      div.prefix-content {
        height: 100%;
      }

      paper-material.autocomplete-suggestion-container {
        left:0;
        right:0;
        bottom: 45px;
        position: absolute;
        z-index: 10; 
        max-height: 180px;
        overflow-y: scroll;
      }
      paper-material.autocomplete-suggestion-container paper-item {
        cursor: pointer;
      }
      
      paper-material.autocomplete-suggestion-container .iron-selected {
        background: #E0E0E0;
      }

      paper-item .avatar-chip-icon {
        @apply(--layout-vertical);
        @apply(--layout-center);
        @apply(--layout-center-justified);
      }
      paper-item .avatar-chip-icon svg, .avatar-chip-icon img {
        width: 100%;
        height: 100%;
      }

      paper-item .avatar-result-icon {
        width: 40px;
        height: 40px;
        margin-right: 8px;
        border-radius: 100%;
        overflow: hidden;
        text-align: center;
        vertical-align: middle;
        font-size: 16px;
        font-weight: bold;
        background-color: var(--paper-chip-icon-background-color, --paper-grey-500);
        color: var(--paper-chip-icon-text-color, --text-primary-color);
        @apply(--layout-vertical);
        @apply(--layout-center);
        @apply(--layout-center-justified);
      }
      paper-item .avatar-result-icon svg, .avatar-result-icon img {
        width: 100%;
        height: 100%;
      }
      
      .autocomplete-suggestions paper-item {
        padding-top: 16px;
        padding-bottom: 16px;
        font-family: 'Roboto', 'Noto', sans-serif;
        font-size: 14px;
      }

    </style>
    
    <paper-input-container no-label-float="[[noLabelFloat]]" always-float-label="[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]" auto-validate$="[[autoValidate]]" disabled$="[[disabled]]" invalid="[[invalid]]">

      <input is="iron-input" type="hidden" class="paper-input-input" bind-value="{{hiddenValue}}"> 
      
      <div class="prefix-container" prefix>
        <content select="[prefix]"></content>
      </div>

      <label hidden$="[[!label]]">[[label]]</label>

      <div class="complete-input-container" id="inputTagsContainer">
				<template is="dom-repeat" items="[[selectedObjects]]">
          <paper-chip label="[[item]]" data-key="[[item.key]]" data-tag$="[[item.tag]]" data-text="[[item.text]]" data-object="[[item]]" on-remove="_onChipRemove" removable="[[!item.readOnly]]">
            <template is="dom-if" if="{{item.imgUrl}}">
              <div class="icon avatar-chip-icon"><img src$="[[item.imgUrl]]"></div>
            </template>
            <template is="dom-if" if="{{!item.imgUrl}}">
              <div class="icon avatar-chip-icon">[[getInitialsFrom(item.text)]]</div>
            </template>
            <h1>[[item.text]]</h1>
          </paper-chip>
				</template>
        <input is="iron-input" id="input" class="autocomplete-input" 
          on-keyup="_keyup" on-keydown="_keydown"
          aria-labelledby$="[[_ariaLabelledBy]]"
          aria-describedby$="[[_ariaDescribedBy]]"
          disabled$="[[disabled]]"
          bind-value="{{inputValue}}"
          invalid="{{invalid}}"
          prevent-invalid-input="[[preventInvalidInput]]"
          allowed-pattern="[[allowedPattern]]"
          validator="[[validator]]"
          type$="[[type]]"
          pattern$="[[pattern]]"
          required$="[[required]]"
          autocomplete$="[[autocomplete]]"
          autofocus$="[[autofocus]]"
          inputmode$="[[inputmode]]"
          minlength$="[[minlength]]"
          maxlength$="[[maxlength]]"
          min$="[[min]]"
          max$="[[max]]"
          step$="[[step]]"
          name$="[[name]]"
          placeholder$="[[_placeholderAfterSelected]]"
          readonly$="[[readonly]]"
          list$="[[list]]"
          size$="[[size]]"
          autocapitalize$="[[autocapitalize]]"
          autocorrect$="[[autocorrect]]"
          on-change="_onChange"
          autosave$="[[autosave]]"
          results$="[[results]]">
        <template is="dom-if" if="{{_suggestions.length}}">
          <paper-material elevation="4" class="autocomplete-suggestion-container">
            <paper-menu class="autocomplete-suggestions">
              <template is="dom-repeat" items="{{_suggestions}}">
      					<paper-item data-key="[[item.key]]" data-text="[[item.text]]" data-tag$="[[item.tag]]" data-object="[[item]]" on-mouseover="_onMouseOverSelectable" on-tap="_onTapSelectable">
                  <template is="dom-if" if="{{item.imgUrl}}">
                    <div class="icon avatar-result-icon"><img src$="[[item.imgUrl]]"></div>
                  </template>
                  <template is="dom-if" if="{{!item.imgUrl}}">
                    <div class="icon avatar-result-icon">[[getInitialsFrom(item.text)]]</div>
                  </template>
                  <span>{{item.text}}</span>
                </paper-item>
              </template>
            </paper-menu>
          </paper-material>
        </template>
      </div>
      
      <div class="suffix-container" suffix>
        <content select="[suffix]"></content>
      </div>      
    </paper-input-container>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'paper-input-autocomplete-chips',

    behaviors: [
      Polymer.IronFormElementBehavior,
      Polymer.PaperInputBehavior,
      Polymer.IronControlState,
      WebPaperElem.InputAutoCompleteBehavior
    ],

    properties: {
      // paper-input-autocomplete
      /**
       * The candidates from local variable.
       */
      selectedObjects: {
        type: Array,
        notify: true,
        value:[]
      },
      /**
       * The candidates from local variable.
       */
      localCandidates:{
        type:Array,
        value:[]
      },
      /**
       * Hidden Input value.
       */
      hiddenValue: {
        type: String,
        notify: true,
      },
      /**
       * Input value.
       */
      inputValue: {
        type: String,
        notify: true,
      },
      
      placeholderAfterSelected: {
        type: String,
      },
      
      _placeholderAfterSelected: {
        type: String,
      }
    },

    listeners: {
      tap: '_onTap',
    },

    observers: [
      '_onInputValueChange(inputValue)',
      '_onSelectedObjectsChange(selectedObjects)',
      '_onSelectedObjectsChange(selectedObjects.splices)',
      '_onAutoCompleteSelectedObjectChange(selectedObject)'
    ],
    
    _onTap: function (e) {
      
      if ((e.target === this.$.inputTagsContainer) && (!this._inputElement.focused)) {
        
        this._inputElement.focus();
      }
    },
    
    _updatePlaceholderAfterSelected: function () {
      if ((this.alwaysFloatLabel) && ((!this.selectedObjects) || (this.selectedObjects.length <= 0))) {
        this._placeholderAfterSelected = this.placeholder;
      } else if ((this.selectedObjects) && (this.selectedObjects.length > 0)) {
        this._placeholderAfterSelected = this.placeholderAfterSelected;
      }
      else {
        this._placeholderAfterSelected = null;
      }
    },
    
    getInitialsFrom: function(value) {
      if (value) {
        return value.replace(/[^A-Z]/g, '');
      }
    },
    
    _onInputValueChange: function (inputValue) {
      var hasSelectedObjects = ((this.selectedObjects) && (this.selectedObjects.length > 0));
      
      this.hiddenValue = ((inputValue === '') && hasSelectedObjects) ? ' ' : inputValue;
    },
    
    _onSelectedObjectsChange: function (selectedObjects) {
      this._updatePlaceholderAfterSelected();
      this._updateHiddenInputTextForFloatLabel();
    },
    
    _onAutoCompleteSelectedObjectChange: function (selectedObject) {
      
      if (!selectedObject) { return; }
      
      if (!this.selectedObjects) {
        this.selectedObjects = [];
      }
      
      var itemIndexONSelectedList = this.selectedObjects.indexOf(selectedObject);
      
      if (itemIndexONSelectedList < 0) {
        this.push('selectedObjects', selectedObject);
      }
      
      this.inputValue = null;
      this._setSelectedItem(null);

      this._updateHiddenInputTextForFloatLabel();

      this._inputElement.focus();
    },
    
    _onChipRemove: function (e) {
      
      e.preventDefault();
      this.arrayDelete('selectedObjects', e.target.dataObject);
      
      this._updateHiddenInputTextForFloatLabel();

      this._inputElement.focus();
    },
    
    _updateHiddenInputTextForFloatLabel: function () {
      
      var hasSelectedObjects = ((this.selectedObjects) && (this.selectedObjects.length > 0));

      this.hiddenValue = (hasSelectedObjects) ? ' ' : null;
      
      if (hasSelectedObjects) {
        this.$.inputTagsContainer.classList.add('chip-item-added');
      } else {
        this.$.inputTagsContainer.classList.remove('chip-item-added');
      }
    },
    
    // Element Lifecycle

    ready: function() {
    },

    attached: function() {
      
    },

    detached: function() {
    },

    // Element Behavior

  });

</script>
